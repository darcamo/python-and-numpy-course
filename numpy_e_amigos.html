<!doctype html>
<html>
	<head>
        <meta name="description" content="Uma apresentação sobre Python para quem já tem noção de programação">
		<meta name="author" content="Darlan Cavalcante Moreira">
        
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Introdução ao Python, Numpy e amigos</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">
        <link rel="stylesheet" href="css/mystyles.css">
        <link rel="stylesheet" href="font-awesome-4.7.0/css/font-awesome.min.css"/>

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
		 var link = document.createElement( 'link' );
		 link.rel = 'stylesheet';
		 link.type = 'text/css';
		 link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		 document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

        <script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>
        <!-- My custom polymer element with a terminal and inside python code -->
        <link rel="import" href="/my_polymer_elements/terminal-tag.html">
        <link rel="import" href="/my_polymer_elements/code-terminal.html">
        <link rel="import" href="/my_polymer_elements/cursor-tag.html">

        <!-- <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js"></script> -->
        <script type="text/javascript" src="bower_components/d3/d3.min.js"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section data-background-image="imagens/hello_python.png" data-background-size="30%" data-background-position="bottom">
                    <h1>Ecossistema Python para Computação Numérica</h1>
                    <!-- <h2>O Ecossistema Python para Computação Numérica</h2> -->
                    <h3>Palestrante: Darlan Cavalcante Moreira</h3>
                </section>

                <!-- <section>
                     <h2>Organização Desswa Apresentação</h2>
                     <ul>
                     <li>Conteúdo</li>
                     <li>Exemplo</li>
                     <li>Exercício</li>
                     </ul>
                     </section> -->
                
				<section>
                    <h2>Objetivos</h2>
                    <ul>
                        <li>Aprender como usar a pilha de bibliotecas para computação científica em Python</li>
                        <li>Aprender algumas ferramentas eficientes como IPython, Jupyter Notebook, debuggers, etc</li>
                        <li>Aprender a criar plots em Python semelhantes a curva como abaixo
                            <img data-src="/imagens/numpy_part/comic_plot.png" width="600" class="displayed"/>
                        </li>
                    </ul>
                </section>

                <section id="baterias">
                    <h2>Qual "bateria" devo usar?</h2>

                    <ul>
                        <li>Python é uma linguagem de programação de uso geral</li>
                        <!-- <li>Mas possui várias bibliotecas voltadas para computação científica</li> -->
                        <li>O ecossistema para pesquisa científica em Python pode ser visto como diversas camadas que incluem: A linguagem Python, <span class="fragment highlight-green"> a biblioteca Numpy</span>, <span class="fragment highlight-green">bibliotecas baseadas no Numpy</span>, <span class="fragment highlight-green">bibliotecas para plot</span>, <span class="fragment highlight-green">terminais mais avançados</span>, <span class="fragment highlight-green">IDEs e similares</span></li>
                        <li>Nesse curso vamos ver parte dessas ferramentas</li>
                    </ul>
                    <!-- https://indranilsinharoy.com/2013/01/06/python-for-scientific-computing-a-collection-of-resources/ -->
                    <!-- <img data-src="/imagens/numpy_part/scientific_stack.png" class="displayed"/> -->
                    <object width="80%" id="scientific_stack" type="image/svg+xml" data="imagens/numpy_part/scientific_stack.svg"></object>
                    <!-- svg = d3.select(document.getElementById("scientific_stack").contentDocument).select("svg") -->
                    
                    <!-- <ul><li><span class="red">Nota:</span> A biblioteca <a href="http://www.numpy.org/">Numpy</a> é o núcleo da computação científica em Python e é a mais importante de se aprender bem</li></ul> -->
                    <aside class="notes">A biblioteca <a href="http://www.numpy.org/">Numpy</a> é o núcleo da computação científica em Python e é a mais importante de se aprender bem</aside>
                </section>

                <section>
                    <h2>Instalando Python</h2>

                    <ul>
                        <li>Python possui duas versões: Python2 e <span class="green">Python3</span></li>
                        <!-- <li>Aqui usaremos a versão 3</li> -->
                        <li>Podem baixar a partir do site oficial em https://www.python.org/downloads/</li>
                        <li>No windows pode ser complicado instalar bibliotecas e suas dependências</li>
                        <li>Um alternativa mais fácil é usar umas das <em class="green">distribuições Python</em> disponíveis:
                            <ul>
                                <li><a href="https://www.continuum.io/downloads/">Anaconda</a> <i class="fa fa-hand-o-right"></i> Usamos essa para os computadores aqui do laboratório</li>
                                <li><a href="https://www.enthought.com/products/canopy/">Canopy</a></li>
                                <li><a href="https://winpython.github.io/">WinPython</a> (possui versão portable)</li>
                            </ul></li>
                        <li><span class="red">Nota:</span> Podem me perguntar sobre o anaconda para mais detalhes depois</li>
                    </ul>
                </section>

                <section>
                
                <section>
                    <h2>IPython</h2>
                    <ul>
                        <li><a href="http://ipython.org/ipython-doc/stable/interactive/tutorial.html">IPython</a> é poderoso shell interativo para a linguagem Python, muito superior ao shell padrão</li>
                        <li>As entradas e saídas são numeradas e você pode recuperar seus valores</li>
                        <li>É possível acessar os valores das entradas com variáveis <code>_i1</code>, <code>_i2</code>, etc</li>
                        <li>Os valores das saídas podem ser acessadas por <code>_1</code>, <code>_2</code>, onde <code>_</code>, <code>__</code> e <code>___</code> acessam a última, penúltima e antepenúltima saída</li>
                    </ul>
                    <code-terminal><in>a = 10</in>
<in>a + 4  # Esqueci de salvar em uma variável</in>
<output>14</output>
<in>b = 16</in>
<in>c = b + _  # '_' possui o valor 14 referente a última saída</in>
<in>c * 2  # c possui valor de 16 + 14</in>
<output>60</output></code-terminal>
                </section>

                <section>
                    <h2>IPython</h2>

                    <ul>
                        <li>Um dos recursos mais úteis do IPython é <a href="http://ipython.readthedocs.io/en/stable/interactive/tutorial.html#tab-completion">completar um comando</a></li>
                        <li>Após digitar parte do comando aperte <kbd>TAB</kbd> para completar</li>
                        <li>Caso haja mais de uma opção uma lista de opções será mostrada</li>
                        <img alt="TAB completion do IPython" src="imagens/numpy_part/ipython_tab_complete.png"/ class="displayed">
                        <li>Também acessar o shell do sistema usando <code>!comando</code> (muito útil para alternar entre pastas, remover arquivos, etc)</li>
                    </ul>
                    <code-terminal><in>!pwd  # Em que pasta estou agora (apenas pwd também funcionaria)</in>
<output>/home/darlan/Desktop</output>
<in>arquivos = !ls  # Lista com nome dos arquivos em Desktop</in></code-terminal>
                </section>

                <section>
                    <h2>IPython</h2>

                    <ul>
                        <li><a href="http://ipython.readthedocs.io/en/stable/interactive/tutorial.html#exploring-your-objects">Obtendo Ajuda com "?"</a>

                            <ul>
                                <li>Digitar <code>algum_obj?</code> mostra diversas informações sobre qualquer objeto, incluindo docstring, definições de funções, informações do construtor, etc</li>
                                <li>Digitar <code>algum_obj??</code> mostrará o código fonte se possível</li>
                                <code-terminal><span class="ipython-in">abs?</span>
<span class="red">Docstring</span>: Return the absolute value of the argument.
<span class="red">Type:</span>      builtin_function_or_method</code-terminal>
                            </ul>
                        </li>
                        
                        
                        <li>Através da introspecção com <code>?</code> e apertando <kbd>TAB</kbd> para completar comandos é possível realmente explorar bem funções, classes, etc.</li>
                    </ul>
                </section>

                <section id="ipython_magic">
                    <h2>IPython</h2>

                    <ul>
                        <li>Outro recurso extremamente útil do IPython são os <a href="http://ipython.readthedocs.io/en/stable/interactive/tutorial.html#magic-functions">comandos mágicos</a></li>
                        <li>Alguns dos comandos mágicos mais úteis são:
                            <ul>
                                <li><tt class="fragment highlight-green">%whos</tt>: Lista variáveis e funções atuais (não mostra variáveis criadas pelo IPython como <code>_3</code>, <code>_i14</code>, etc)</li>
                                <code-terminal id="code_terminal_whos" dontshowcursor style="font-size:90%;"><in>a = [1,2,3]</in>
<in>b = "Olá Mundo"</in>
<in>whos
Variable   Type    Data/Info
----------------------------
a          list    n=3
b          str     Hello
</in>
<in>whos list
Variable   Type    Data/Info
----------------------------
a          list    n=3</in></code-terminal>
                                <li><tt class="fragment highlight-green">%edit testando.py</tt>: Abre 'testando.py' e executa o código após sair</li>
                                <code-terminal id="code_terminal_edit" dontshowcursor><in>edit testando.py
Editing... Waiting for Emacs...</in></code-terminal>
                                <li><tt class="fragment highlight-green">%run testando.py</tt>: Executa testando.py como um script <span class="fragment highlight-green"><i class="fa fa-hand-o-right"></i> Também podemos passar opções como "-p" ou "-t"</span></li>
                                <code-terminal id="code_terminal_run" dontshowcursor><in>cat testando.py  # Vamos ver o conteúdo que salvei no arquivo
a = 10
b = 20
print(a * b)</in>
<in>run testando.py  # TAB completa o nome do arquivo
200
</in>
<in>whos
Variable   Type    Data/Info
----------------------------
a          int     10
b          int     20</in></code-terminal>
                                <code-terminal id="code_terminal_run_profile" dontshowcursor><in>run -p testando.py</in>
Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     2    0.000    0.000    0.000    0.000 {built-in method io.open}
     1    0.000    0.000    0.000    0.000 interactiveshell.py:2431(safe_execfile)
     1    0.000    0.000    0.000    0.000 {built-in method builtins.compile}
     2/1  0.000    0.000    0.000    0.000 {built-in method builtins.exec}
     1    0.000    0.000    0.000    0.000 py3compat.py:182(execfile)
     1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
     1    0.000    0.000    0.000    0.000 posixpath.py:318(normpath)
     1    0.000    0.000    0.000    0.000 posixpath.py:145(dirname)
     1    0.000    0.000    0.000    0.000 _bootlocale.py:23(getpreferredenco
     ... ... ...</code-terminal>
                                <li><tt class="fragment highlight-green">%paste</tt>: Cola e executa um bloco de código da área de transferência</li>
                                <li><tt class="fragment highlight-green">%timeit</tt>: Executa uma expressão e mostra tempo decorrido</li>
                                <code-terminal id="code_terminal_timeit" dontshowcursor style="font-size:90%"><in>%timeit 4 * 5
100000000 loops, best of 3: 12.3 ns per loop</in></code-terminal>
                                <!-- <li><tt class="fragment highlight-green">%macro</tt>: Define um macro para futura execução</li> -->
                                <li><tt class="fragment highlight-green">%autocall</tt>: Dispensa os parêntesis em uma chamada de função</li>
                                <code-terminal id="code_terminal_autocall" dontshowcursor><in>sum [1,2,3]
-------> sum([1,2,3])</in>
<output>6</output></code-terminal>
                                    
                                <li><tt class="fragment highlight-green">%quickref</tt>: Cartão de referência do IPython <i class="green fa fa-hand-o-right"></i> Veja também <code>%comando?</code></li>
                            </ul>
                        </li>
                    </ul>
                    
                </section>

                <!-- <section>
                     <h2>IPython</h2>

                     <ul>
                     <li>Outro recurso extremamente útil do IPython são os <a href="http://ipython.readthedocs.io/en/stable/interactive/tutorial.html#magic-functions">comandos mágicos</a></li>
                     <li>Alguns dos comandos mágicos mais úteis são:
                     <ul>
                     </ul>
                     </li>
                     </ul>
                     </section> -->
                

                </section>

                <section>
                    <section>
                        <h2>Jupyter Notebook</h2>

                        <ul>
                            <li class="fragment">Surgiu inicialmente como IPython Notebook, inspirado pelo Mathematica</li>
                            <li class="fragment">Cada notebook quando aberto está associado a um <span class="green">kernel</span></li>
                            <li class="fragment">Pode ser usado online em <a href="https://try.jupyter.org">https://try.jupyter.org</a></li>
                            <li class="fragment"><a href="https://nbviewer.jupyter.org/">nbviewer</a>: Site com vários notebooks interessantes, como por exemplo <a href="https://nbviewer.jupyter.org/github/unpingco/Python-for-Signal-Processing/blob/master/Expectation_Maximization.ipynb">esse aqui</a> (<a href="http://localhost:8888/notebooks/Expectation_Maximization.ipynb">versão local</a>)</li>
                            <li class="fragment">Pode ser instalado pelo Anaconda</li>
                            <li class="fragment">Rode o comando <code>jupyter notebook</code> para iniciar <span class="green"><i class="fa fa-hand-o-right"></i> Tentem agora</span></li>
                            <li class="fragment"><span class="red">Nota:</span> Existem serviços que rodam na nuvem e permitem criar e executar notebooks como <a href="https://cloud.sagemath.com/settings">SageMathCloud</a> e <a href="https://wakari.io/">Wakario</a>
                                <img alt="" src="imagens/numpy_part/sage_math_cloud.png" class="displayed" style="width: 700px;"/>
                            </li>
                        </ul>
                        
                    </section>

                    <section>
                        <h2>Jupyter Notebook</h2>
                        <h3>Dashboard</h3>

                        <ul>
                            <li>Ao executar o notebook uma aba do navegador é aberta com o dashboard</li>
                            <li>Vemos os arquivos na pasta onde o comando <code>jupyter notebook</code> foi executado</li>
                            <img alt="" src="imagens/numpy_part/jupyter_dashboard.png" style="border:none;"/>
                        </ul>
                        
                    </section>

                    <section>
                        <h2>Jupyter Notebook</h2>
                        <h3>Editor</h3>

                        <ul>
                            <li>No dashboard, cliquem em "New" e escolham o kernel indicado como Python3 para criar um novo notebook</li>
                            <li class="fragment green">Executar o tour pela interface em "Help <i class="fa fa-arrow-right"></i> User Interface Tour" </li>
                            <li class="fragment">As células podem ser de dois tipos: markdown e code</li>
                            <li class="fragment">Células do tipo "markdown" contém texto que é renderizado usando a <a href="https://daringfireball.net/projects/markdown/syntax">notação markdown</a></li>
                            <li class="fragment">Células do tipo "code" contém código que será executado, possivelmente resultando em alguma saída mostrada abaixo</li>
                            <li class="fragment">Em alguns caso a saída será mostrada em um <span class="green">formato mais apropriado</span></li>
                        </ul>
                    </section>

                    <section>
                        <h2>Jupyter Notebook</h2>
                        <h3>Exercício</h3>
                        <ul>
                            <li>Crie uma célula markdown contendo texto com alguma formatação em markdown</li>
                            <li>Uma célula abaixo definindo duas variáveis com números</li>
                            <li>Crie uma célula abaixo somando as duas variáveis</li>
                            <li>Faça um merge das duas células anteriores</li>
                            <li>Crie uma célula vazia</li>
                            <li>Delete a célula vazia recém criada</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Jupyter Notebook</h2>
                        <h3>Mais que um terminal</h3>
                        <ul>
                            <li>O editor do Jupyter possui algumas melhorias que não são possíveis em um terminal</li>
                            <ul>
                                <li><code>obj?</code> mostra informações do objeto em um <em>pager</em></li>
                                <li><kbd>Shift</kbd>+<kbd>Enter</kbd> em uma função mostra a docstring da função em um popup</li>
                                <li><span class="green">Rich Display System</span>: Estende o método nativo <code>__repr__</code> do Python para outras representações e o notebook vai escolher a mais apropriada</li>
                                <ul><li>Representações possíveis: HTML, JSON, PNG, JPEG, SVG, LaTeX</li></ul>
                                <li>Etc.</li>
                            </ul>
                        </ul>
                    </section>
                    
                </section>
                
                <section>
                    <h2>Numpy Arrays</h2>

                    <ul>
                        <!-- <li>A biblioteca <a href="http://www.numpy.org/">Numpy</a> é o núcleo da computação científica em Python</li> -->
                        <li>Numpy nos fornece um <em>array multidimensional</em> de alto desempenho e ferramentas para trabalhar com esses arrays</li>
                        <li class="fragment" data-fragment-index="1">Um array armazena um conjunto de valores, todos do mesmo <span class="green">tipo</span>, e possui um <span class="green">formato</span> (shape)</li>
                        <li class="fragment" data-fragment-index="2">O shape de um array é uma tupla de inteiros não negativos e seu número de elementos corresponde ao <span class="green">rank</span> do array</li>
                        <!-- <li>Geralmente procuramos <em>vetorizar</em> nosso código como quando trabalhamos com <a href="http://scipy.github.io/old-wiki/pages/NumPy_for_Matlab_Users">MATLAB/Octave</a></li> -->
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>RANK: Não confundir a noção esse rank
                                com o rank de álgebra linear.</li>
                            <li>Um array pode ter quantas dimensões
                                forem desejadas. Aqui temos exemplos com
                                uma, duas, e três dimensões.</li>
                        </ul>
                    </aside>                        
                    <div class="container fragment" data-fragment-index="1">
                        <div class="element">
                            <div>1D numpy array</div>
                            <div id="numpy-1darray"></div>
                            <div>Shape: (4,)</div>
                            <div>Tipo: int</div>
                        </div>
                        <div class="element">
                            <div>2D numpy array</div>
                            <div id="numpy-2darray"></div>
                            <div>Shape: (2,3)</div>
                            <div>Tipo: float</div>
                        </div>

                        <div class="element">
                            <div>3D numpy array</div>
                            <!-- <div id="AAnumpy-3darray"></div> -->
                            <!-- <img src="imagens/numpy_part/numpy_3d_array.svg"/> -->
                            <object type="image/svg+xml" data="imagens/numpy_part/numpy_3d_array_manual.svg"></object>
                            <div>Shape: (4,3,2)</div>
                            <div>Tipo: int</div>
                        </div>
                        
                    </div>
                    
                    
                    <!-- <img src="imagens/numpy_part/numpy_1d_array.svg"/> -->
                    
                    <!-- <div class="numpy_table">
                         <div>1d Numpy Array</div>
                         <table><tbody>
                         <tr>
                         <td>7</td>
                         <td>2</td>
                         <td>9</td>
                         <td>10</td>
                         </tr>
                         </tbody></table>
                         <div>shape: (4,)</div>
                         </div>
                         <div class="numpy_table">
                         <div>2d Numpy Array</div>
                         <table><tbody>
                         <tr>
                         <td>5.2</td>
                         <td>3.0</td>
                         <td>4.5</td>
                         </tr>
                         <tr>
                         <td>9.1</td>
                         <td>0.1</td>
                         <td>0.3</td>
                         </tr>
                         </tbody></table>
                         <div>shape: (4,)</div>
                         </div> -->
                </section>

                <section>    
                    
                <section>
                    <h2>Criando Arrays</h2>
                    <ul>
                        <li>Existem diversas maneiras de criar um array</li>
                        <li>A mais direta é listando seus elementos</li>
                    </ul>
                    <code-terminal><in>import numpy as np  # Importa numpy como 'np'</in>
<in>a = np.array([7, -2, 9, 10])</in>
<in>a</in>
<output>array([ 7, -2,  9, 10])</output>
<in>a.shape</in>
<output>(4,)</output>
<in></in>a.ndim
<output>1</output>
<in>b = np.array([[5.2, 2, -9, 10], [-10, 2, 9, 10]])</in>
<in>b</in>
<output>
array([[  5.2,   2. ,  -9. ,  10. ],
       [-10. ,   2. ,   9. ,  10. ]])</output>
<in>b.shape</in>
<output>(2,4)</output></code-terminal>
                </section>
                    
                <section>
                    <h2>Datatype</h2>
                    <ul>
                        <li>Os elementos de um array só podem ser do mesmo tipo</li>
                        <li>Um array é muito eficiente em armazenar e
                            computar se o tipo for <code>int</code>, <code>float</code>, ou <code>complex</code></li>
                        <li>Podemos verificar o tipo de um array através da propriedade "dtype"</li>
                    </ul>
                    <code-terminal><in>a = np.array([1, 5, -7, 15, -22, 4])</in>
<in>a.dtype</in>
<output>dtype('int64')</output>
<in>b = np.array([[1, 5, -7], [15, -22, 4]])</in>
<in>b.dtype</in>
<output>dtype('float64')</output>
<in>c = np.array([2, 4, 2-4j])</in>
<output>dtype('complex128')</output>
<in>d = np.array([-2,55.3, 22.1], <span class="green">dtype=complex</span>)  # Especifica o dtype</in>
<in>d.dtype</in>
<output>dtype('complex128')</output>
</code-terminal>
                </section>

                <section>
                    <h2>Data Shape</h2>
                    <ul>
                        <li>Podemos verificar o formado de um array através da propriedade <span class="green">shape</span></li>
                        <li>Além da propriedade shape podemos usar <span class="green">size</span> para determinar o número de elementos em um array</li>
                        <li>Use o método <span class="green">reshape</span> para mudar o formato do array</li>
                    </ul>
                    <code-terminal><in>a = np.array([[1, 5, -7, 12], [7, 15, -22, 4], [1, 2, 3, 4]])</in>
<in>a.shape</in>
<output>(3, 4)</output>
<in>a.size</in>
<output>12</output>
<in>a = a.reshape((2, 6))  # reshape(2, 6) também funciona</in>
<in>a.shape</in>
<output>(2, 6)</output>
<in>a = a.reshape(2,-1,2)  # Use -1 para determinar o valor automaticamente</in>
<in>a.shape</in>
<output>(2, 3, 2)</output></code-terminal>
                </section>
                
                
                    <section>
                        <h2>Criando Arrays</h2>

                        <ul>
                            <li>Há várias funções que retornam arrays no numpy</li>
                            <li>Mais comuns: <code>zeros</code>, <code>ones</code>, <code>eye</code>, <code>empty</code></li>
                        </ul>
                        
                        <code-terminal><in>a = np.zeros((2,2))  # Cria um arra de zeros</in>
<in>b = np.ones((2,3))</in>
<in>c = np.eye(2, dtype=complex) # Especificamos o dtype como complex</in>
<in>print(a), print(b), print(c)</in>
[[ 0.  0.]
 [ 0.  0.]]
[[ 1.  1.  1.]
 [ 1.  1.  1.]]
[[ 1.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j]]
<in>d = np.empty((2,3), dtype=np.int16)  # Inteiro de apenas 16 bits</in>
<in>print(d)</in>
[[91  0 34]
 [ 7 24 44]]</code-terminal>
                        <aside class="notes">
                            <ul>
                                <li>Percebam que passamos uma tupla como datashape </li>
                                <li>Há parâmetros opcionais como o dtype</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h2>Criando Arrays</h2>
                        <ul>
                            <li>Podemos também criar arrays com valores aleatórios, em um intervalo, etc</li>
                        </ul>
                        <code-terminal><in>np.random.random((2,3))  # Números aleatórios entre 0 e 1</in>
<output>
[[ 0.17926073  0.55768193  0.91629068]
 [ 0.42331764  0.81109184  0.94441903]]</output>
<in>np.random.normal(loc=10, scale=3, size=(2,4)) # mean=10, var=3</in>
<output>
array([[  0.57156707,   2.24492393,  11.96929131,   5.72524926],
       [  8.42069327,   6.6472876 ,  11.46130987,   6.91887518]])
</output>
<in>10 + math.sqrt(3) * np.random.randn(2,4)  # Mesmo que o comando anterior</in>
<output>
array([[  8.6556823 ,  11.76621921,  13.06145845,  10.29941938],
       [  7.71243543,   6.75014684,   8.8052951 ,   8.84438892]])
</output>
<in>np.arange(3, 15, 2)  # Varia de 3 a 15 (sem incluir o 15) com passo 2</in>
<output>array([ 3,  5,  7,  9, 11, 13])</output>
<in>np.linspace(0, 20, 9)  # 9 valores, indo de 0 a 20</in>
<output>array([  0. ,   2.5,   5. ,   7.5,  10. ,  12.5,  15. ,  17.5,  20. ])</output></code-terminal>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Operações Básicas</h2>
                        <ul>
                            <li>Operadores aritméticos em arrays operam elemento-a-elemento</li>
                        </ul>
                        <code-terminal><in>a = np.array([20,30,40,50])</in>
<in>b = np.arange( 4 )</in>
<in>b</in>
<output>array([0, 1, 2, 3])</output>
<in>c = a-b</in>
<in>c</in>
<output>array([20, 29, 38, 47])</output>
<in>b**2</in>
<output>array([0, 1, 4, 9])</output>
<in>10*np.sin(a)</in>
<output>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</output>
<in>a<35</in>
<output>array([ True, True, False, False], dtype=bool)</output></code-terminal>
                        
                    </section>
                
                    <section>
                        <h2>Operações Básicas</h2>
                        <ul>
                            <li>O operador <code>*</code> não é exceção e efetua uma multiplicação elemento-a-elemento</li>
                            <li>Para produto matricial use <code>@</code> ou o método <code>dot</code></li>
                        </ul>
                        <code-terminal><in>A = np.array([[1,1], [0,1]])</in>
<in>B = np.array([[2,0], [3,4]])</in>
<in>A*B  # Produto elemento-a-elemento</in>
<output>
array([[2, 0],
       [0, 4]])</output>
<in>A.dot(B)  # Produto matricial</in>
<output>
array([[5, 4],
       [3, 4]])
</output>
<in>A @ B  # Produto matricial: Python 3.5 ou superior</in>
<output>
array([[5, 4],
       [3, 4]])
</output></code-terminal>
                    </section>

                    <section>
                        <h2>Operações Básicas</h2>
                        <ul>
                            <li>Algumas operações, como <code>+=</code> e <code>*=</code>, modificam o array atual ao invés de criar um novo array <i class="fa fa-hand-o-right"></i> Note que o datatype não pode mudar</li>
                        </ul>

                        <code-terminal><in>a = np.ones((2,3), dtype=int)  # 'a' é uma matriz de inteiros iguais a 1</in>
<in>b = np.random.random((2,3))  # 'b' é uma matriz de números de ponto flutuante</in>
<in>a *= 3</in>
<in>a</in>
<output>
array([[3, 3, 3],
       [3, 3, 3]])</output>
<in>b += a  # Sobrescreve 'b' com o valor de a+b</in>
<in>b</in>
<output>
array([[ 3.417022  ,  3.72032449,  3.00011437],
       [ 3.30233257,  3.14675589,  3.09233859]])</output>
<in>a += b  # 'b' NÃO é automaticamente convertido para um ipo inteiro</in>
<span class="red">TypeError:</span> Cannot cast ufunc add output from dtype('float64') to dtype('int64')<br/>with casting rule 'same_kind'</code-terminal>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Principais Operações em Arrays</h2>
                        <ul>
                            <li>As diversas funções matemáticas são implementadas como <code>np.nome_da_função</code> e algumas estão também disponíveis como métodos do array</li>
                            <li class="fragment">Experimente digitar "a." no IPython e apertar <kbd>TAB</kbd> para ver as sugestões e use "?" para ver o help</li>
                        </ul>

                        <code-terminal><in>a = np.random.random((2,3))</in>
<in>a</in>
<output>
array([[ 0.18626021,  0.34556073,  0.39676747],
       [ 0.53881673,  0.41919451,  0.6852195 ]])</output>
<in>a.sum()</in>
<output>2.5718191614547998</output>
<in>a.min()</in>
<output>0.1862602113776709</output>
<in>a.max()</in>
<output>0.6852195003967595</output></code-terminal>
                    </section>


                    <section>
                        <h2>Principais Operações em Arrays</h2>
                        <ul>
                            <li>NumPy possui as funções matemáticas usuais: <span class="green">sin</span>, <span class="green">cos</span>, <span class="green">exp</span>, etc.</li>
                            <li>Elas são chamadas de "universal functions" (ufuncs)</li>
                            <li>Essas funções <span class="green">operam individualmente em cada elemento do array</span>, produzindo um array como saída</li>
                        </ul>

                        <code-terminal><in>B = np.arange(3)</in>
<in>B</in>
<output>array([0, 1, 2])</output>
<in>np.exp(B)</in>
<output>array([ 1.        ,  2.71828183,  7.3890561 ])</output>
<in>np.sqrt(B)</in>
<output>array([ 0.        ,  1.        ,  1.41421356])</output>
<in>C = np.array([2., -1., 4.])</in>
<in>np.add(B, C)  # Mesmo que B + C</in>
<output>array([ 2.,  0.,  6.])</output></code-terminal>
                    </section>
                </section>
                
                <section>
                    <section id="indexando_arrays">
                        <h2>Indexando Arrays</h2>

                        <ul>
                            <li>Arrays com uma dimensão podem ser indexados,
                            fatiados, e iterados de forma semelhante a listas</li>
                        </ul>
                        
                        <code-terminal dontshowcursor><in>a = np.arange(10)**3</in>
<in>a</in>
<output>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</output>
<span class="fragment" data-fragment-index="1"><in>a[2]</in>
<output>8</output></span>
<span class="fragment" data-fragment-index="2"><in>a[2:5]</in>
<output>array([ 8, 27, 64])</output></span>
<span class="fragment" data-fragment-index="3"><in>a[:6:2] = -1000  # Seta elementos nas posições 0, 2 e 4 </in>
<in>a</in>
<output>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</output></span>
<span class="fragment" data-fragment-index="4"><in>a[ : :-1]  # Inverte a ordem dos elementos de a</in>
<output>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</output></span></code-terminal>
                        <svg id="indexando-arrays-placeholder"></svg>
                    </section>

                    <section id="indexando_arrays2">
                        <h2>Indexando Arrays</h2>
                        <ul>
                            <li>Arrays multidimensionais podem conter um índice por eixo</li>
                            <li>Esses índices são separados por vírgula</li>
                            <li class="fragment" data-fragment-index="5">Podemos fornecer menos índices que eixos</li>
                            <li class="fragment" data-fragment-index="6">Também podemos usar índices negativos</li>
                        </ul>
                        <div class="container" style="width:1000px;">
                            <div class="element" style="width:650px;"><code-terminal dontshowcursor style="font-size:90%;"><in>def f(x,y): return 10*x+y</in>
<in>b = np.fromfunction(f, (5,4), dtype=int)</in>
<span class="fragment" data-fragment-index="1"><in>b[2,3]</in>
<output>23</output></span>
<span class="fragment" data-fragment-index="2"><in>b[0:5, 1]
<output>array([ 1, 11, 21, 31, 41])</output></span>
<span class="fragment" data-fragment-index="3"><in>b[ : ,1]  # Mesmo que exemplo anterior
<output>array([ 1, 11, 21, 31, 41])</output></span>
<span class="fragment" data-fragment-index="4"><in>print( b[1:3, : ] )
[[10, 11, 12, 13],
 [20, 21, 22, 23]]</span></in>
<span class="fragment" data-fragment-index="5"><in>print(b[0])  # slices completos p/ os que faltam</in>
<output>[0, 1, 2, 3]</output></span>
<span class="fragment" data-fragment-index="6"><in>print(b[-1])</in>
<output>[40, 41, 42, 43]</output></span>
<span class="fragment" data-fragment-index="7"><in>print( b[2:4,::2] )  # Combina dois slices
[[20, 22],
 [30, 32]]</in></span></code-terminal></div>
                        <div class="element" style="transform: scale(0.7,0.7);" ><svg id="indexando-arrays-placeholder2"></svg></div>
                        </div>

                        <aside class="notes">
                            <ul>
                                <li>Quando um número menor de índices que o número
                                    de eixos é fornecido os índices que faltam são
                                    considerados slices completos </li>
                                <li>The dots (...) represent as many colons as
                                needed to produce a complete indexing
                                    tuple. For example, if x is a rank 5 array (i.e., it has 5 axes), then
                                    <ul>
                                        <li>x[1,2,...] is equivalent to x[1,2,:,:,:],</li>
                                        <li>x[...,3] to x[:,:,:,:,3] and</li>
                                        <li>x[4,...,5,:] to x[4,:,:,5,:]</li>
                                    </ul></li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h2>Indexando Arrays</h2>
                        <ul>
                            <li>Podemos usar também <code>...</code> para representar <span class="green">tantos ":" quanto necessário</span> para produzir uma indexação completa</li>
                            <li>Ex: Considere por exemplo um array <code>x</code> de rank 5</li>
                            <li>Temos então que:</li>
                            <ul>
                                <li><code>x[1,2,...]</code> equivale a <code>x[1,2,:,:,:]</code>,</li>
                                <li><code>x[...,3]</code> equivale a <code>x[:,:,:,:,3]</code></li>
                                <li><code>x[4,...,5,:]</code> equivale a <code>x[4,:,:,5,:]</code></li>
                                <li>Etc.</li>
                            </ul>
                        </ul>
                    </section>

                    <section>
                        <h2>Indexando Arrays</h2>
                        <ul>
                            <li>Ao indexar uma dada dimensão o array resultante não possui aquela dimensão, mas para slices a dimensão continua existindo</li>
                            <li>Compare os exemplos abaixo (especialmente o shape do resultado)</li>
                        </ul>
                        <!-- <div class="displayed"><img alt="" data-src="imagens/numpy_part/indexing.png" height="500px"/></div> -->
                        <div class="displayed"><object type="image/svg+xml" data="imagens/numpy_part/indexing.svg"></object></div>
                    </section>

                    <section id="indexando_arrays3">
                        <h2>Indexando Arrays</h2>
                        <h3>Vetores Booleanos</h3>

                        <ul>
                            <li>Arrays booleanos podem ser usados para indexar outros arrays</li>
                            <li>Isso é especialmente útil para pegar elementos obedecendo certas condições</li>
                            <li>Exemplo:</li>
                        </ul>
                        <div class="container" style="width:1000px;">
                            <div class="element" style="width:570px;"><code-terminal dontshowcursor style="font-size:95%;"><in>b = np.random.randint(0,100, size=(4,5))</in>
<in>linhas = np.array([False, True, True, False])</in>
<span class="fragment" data-fragment-index="1"><in>b[linhas]</in>
<output>
array([[20,  5, 68, 48, 23],
       [83, 70, 12, 73, 31]])</output></span>
<span class="fragment" data-fragment-index="2"><in>b[b < 30]  # Pega elementos que 30</in>
<output>array([20,  5, 23, 12,  0])</output></span>
<span class="fragment" data-fragment-index="3"><in>idx = (b >= 30); b[idx]  # Elementos >= 30</in>
    <output>array([39, 87, 96, ... ... , 94, 30, 87])</output></span>
<span class="fragment" data-fragment-index="4"><in># Colunas com todos os elementos são >= 30</in>
<in>b[:, idx.all(axis=0)]  # Indexa colunas</in>
<output>
array([[97],
       [48],
       [73],
       [30]])</output></span></code-terminal></div>
                            <div class="element" style="transform: scale(0.8) translate(-50px,0);"><svg id="indexando-arrays-placeholder3"></svg></div>
                        </div>
                    </section>
                    
                </section>
                
                <section id="manipulando_o_shape">
                    <h2>Manipulando o <em>shape</em></h2>
                    <ul>
                        <li><em>shape</em> define o número de elementos em cada dimensão</li>
                        <li>Há várias maneiras de manipular o shape de um array</li>
                        <li>Ao invés de <span class="green">reshape</span> podemos usar <span class="green">resize</span> <i class="fa fa-hand-o-right"></i> modifica o array</li>
                        <li><i class="fa fa-lightbulb-o"></i> Dica: Use "-1" em uma dimensão e o numpy vai detectar o valor correto</li>
                    </ul>

                    <div class="container" style="width:1000px;">
                        <div class="element" style="width:700px;">
                            <code-terminal style="font-size:84%;" dontshowcursor><in>a = np.floor(10*np.random.random((3,4)))</in>
<in>a</in>
<output># Ver matriz ao lado
<!-- array([[ 2.,  8.,  0.,  6.],
[ 4.,  5.,  1.,  1.],
[ 8.,  9.,  3.,  6.]]) --></output>
<span class="fragment"><in>a.shape  # Apenas retorna o shape atual do array</in>
<output>(3, 4)</output></span>
<span class="fragment"><in>a.ravel()  # "achata" o array (sem modificar)</in>
<output>array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])</output></span>
<span class="fragment"><in>a.shape = (6, 2)  # Semelhante a "a = a.reshape(6, 2)"</in></span>
<span class="fragment"><in>a.T  # Não modifica o array</in>
<output>
array([[ 2.,  0.,  4.,  1.,  8.,  3.],
       [ 8.,  6.,  5.,  1.,  9.,  6.]])</output></span>
<span class="fragment"><in>a.resize(2,6)</in>
<in>a</in>
<output>
array([[ 2.,  0.,  4.,  1.,  8.,  3.],
       [ 8.,  6.,  5.,  1.,  9.,  6.]])</span>
</output></code-terminal>
                        </div>

                        <div class="element" style="width:271px; height:294px;position:relative;">
                            <!-- <div>Shape de <span class="green">a</span></div> -->
                            <div style="transform: scale(0.8,0.8) translateX(-20%);"><svg id="manipulando_o_shape_placeholder" style="position:absolute; left: 0px; top:0px;"></svg></div>
                        </div>
                    </div>
                </section>

                <section>
                    <h2>Empilhando Arrays</h2>
                    <!-- https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#stacking-together-different-arrays -->
                    <ul>
                        <li>Vários arrays podem ser empilhados ao longo de um determinado eixo</li>
                        <li>Algumas das funções para isso são <code>hstack</code>, <code>vstack</code>, <code>concatenate</code> e <code>stack</code>, np.concatenate</li>
                    </ul>
                    <code-terminal><in>a = np.floor(10*np.random.random((2,2)));  a</in>
<output>
array([[ 8.,  8.],
       [ 0.,  0.]])</output>
<in>b = np.floor(10*np.random.random((2,2)));  b</in>
<output>
array([[ 1.,  8.],
       [ 0.,  4.]])
</output>
<in>np.vstack((a,b))  # Necessário ter o mesmo shape (exceto na primeira dimensão)</in>
<output>
array([[ 8.,  8.],
       [ 0.,  0.],
       [ 1.,  8.],
       [ 0.,  4.]])</output>
<in>np.hstack((a,b))  # Necessário ter o mesmo shape (exceto na segunda dimensão)</in>
<output>
array([[ 8.,  8.,  1.,  8.],
       [ 0.,  0.,  0.,  4.]])</output></code-terminal>
                </section>
                
                <section id="memory_order">
                    <h2>Representação de um Array na Memória</h2>

                    <ul>
                        <li>Um array é armazenado em uma região contínua de memória <span class="green">independentemente de sua dimensão</span></li>
                        <li class="fragment" data-fragment-index="1">Se mudarmos o shape de um array normalmente não é feita uma cópia</li>
                        <li class="fragment" data-fragment-index="2">A ordem em que os elementos são armazenados na memória pode tanto ser como "<span class="green">em C</span>" (padrão) ou como "<span class="green">em Fortran</span>"</li>

                        <!-- <img  class="displayed" alt="" src="imagens/numpy_part/numpy_C_order_fortran_order.png" style="background-color:LightBlue;"/> -->


                        <li class="fragment" data-fragment-index="3"><span class="green">Ordem do C</span>: A última dimensão varia mais rapidamente
                        <div style="position: relative;">
                            <div style="position: absolute; left: 120px; top: -40px; transform: translate(-25%, 0);">Representação no Numpy</div>
                            <div style="position: absolute; right: 160px; top: -40px;">Representação na Memória</div>
                            <svg id="c_order" class="displayed" style="margin-top: 50px;"></svg></div></li>
                        
                        <li class="fragment" data-fragment-index="4"><span class="green">Ordem do Fortran</span>: A primeira dimensão varia mais rapidamente

                        <div style="position: relative;">
                            <div style="position: absolute; left: 120px; top: -40px; transform: translate(-25%, 0);">Representação no Numpy</div>
                            <div style="position: absolute; right: 160px; top: -40px;">Representação na Memória</div>
                            <svg id="fortran_order" class="displayed" style="margin-top: 50px;"></svg>
                        </div></li>

                    </ul>
                </section>

                <section>
                <section>
                    <h2>Cópias e Views</h2>
                    <!-- https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#copies-and-views -->
                    <ul>
                        <li>Quando operando e manipulando arrays, as vezes os dados são copiados em um novo array e as vezes não</li>
                        <li>Casos sem cópia:</li>
                        <ul>
                            <li>Assinalamento (Python também funciona assim para tipos mutáveis)</li>
                            <li>Mudança de shape</li>
                            <li>Argumentos de funções</li>
                        </ul>
                        <code-terminal dontshowcursor><in>a = np.arange(12)</in>
<in>b = a            # Nenhum objeto novo é criado com um assinalamento</in>
<in>b is a           # "a" e "b" são dois nomes para o mesmo array</in>
<output>True</output>
<in>b.shape = 3,4    # Muda apenas o shape do array sem mudar os dados na memória</in>
<in>a.shape</in>
<output>(3, 4)</output>
<in>def f(x):
...           print(id(x))</in>
<in>id(a)                           # id é um identificador único de um objeto</in>
<output>148293216</output>
<in>f(a)</in>
<output>148293216</output></code-terminal>
                    </ul>
                </section>

                <section>
                    <h2>Cópias e Views</h2>
                    <ul>
                        <li>Diferentes arrays podem compartilhar os mesmos dados na memória</li>
                        <li>O método <code>view</code> de um array cria um novo objeto array que utiliza os mesmos dados</li>
                        <li>Mudanças feitas nos dados de um são refletidas no outro array, mas os dois não são o mesmo objeto como ocorre em Python com um assinalamento</li>
                        <li>Os dois objetos podem ter formas diferentes</li>
                    </ul>
                    <code-terminal dontshowcursor><in>c = a.view()</in>
<in>c is a</in>
<output>False</output>
<in>c.base is a                        # c é uma "view" dos dados de 'a'</in>
<output>True</output>
<in>c.flags.owndata</in>
<output>False</output>
<in>c.shape = 2,6                      # o shape de 'a' não muda</in>
<in>a.shape</in>
<output>(3, 4)</output>
<in>c[0,4] = 1234                      # o shape de 'a' muda</in>
<in>a</in>
<output>
array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])</output></code-terminal>
                </section>


                <section>
                    <h2>Cópias e Views</h2>
                    <ul>
                        <li>Fatiar um array retorna um view do array</li>
                        <li>Para criar um cópia independente de um array use o método <code>copy</code></li>
                    </ul>
                    <code-terminal style="font-size:95%;" dontshowcursor><in>s = a[ : , 1:3]</in>
<in>s[:] = 10  # s[:] é um view de s. Note a diferença entre s=10 e s[:]=10</in>
<in>a</in>
<output>
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])</output>
<in>d = a.copy()  # um novo objeto array com dados novos é criado</in>
<in>d is a</in>
<output>False</output>
<in>d.base is a  # "d" não compartilha nada com "a"</in>
<output>False</output>
<in>d[0,0] = 9999</in>
<in>a</in>
<output>
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])</output></code-terminal>
                </section>

                </section>
                
                <section id="axis-params">
                    <h2>Operações matemáticas</h2>
                    <ul>
                        <li>Já vimos alguns métodos que operam elemento-a-elemento, onde o resultado possui o mesmo rank que a entrada</li>
                        <li>Alguns métodos reduzem a dimensão obtendo um
                        resultado de rank menor</li>
                        <li>Exemplo: <code>mean</code>, <code>var</code>, <code>sum</code>, etc.</li>
                        <!-- <li>Obtemos um escalar</li> -->
                        <li class="fragment" data-fragment-index="2">É possível indicar sobre qual dimensão efetuar a operação</li>
                    </ul>
                    <div class="container" style="min-width:1000px;">
                        <div class="element" style="width: 65%;">
                    <code-terminal dontshowcursor><in>a = np.random.randint(3, 4)</in>
<in>a</in>
<output>Ver matriz ao lado
array([[31, 11, 15, 69],
       [ 8, 75, 68, 54],
       [31, 47, 86, 23]])</output>
<in>a.sum()</in>
<output class="fragment" data-fragment-index="1">518</output>
<in class="fragment" data-fragment-index="2">a.sum(axis=0)</in>
<output class="fragment" data-fragment-index="3">array([ 70, 133, 169, 146])</output>
<in class="fragment" data-fragment-index="4">a.sum(axis=1)</in>
<output class="fragment" data-fragment-index="5">array([126, 205, 187])</output></code-terminal>
                        </div>
                        <div class="element"><svg id="axis-param-placeholder" class="displayed" ></svg></div>
                    </div>
                </section>

                
                <!-- <section>
                     <h2>Functions and Methods Overview</h2>
                     https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview
                     <ul>
                     <li>Chequem a <a href="http://docs.scipy.org/doc/numpy/reference/">referência no numpy</a> para muito mais informações sobre o numpy</li>
                     <li>o <a href="https://docs.scipy.org/doc/scipy/reference/">Scipy</a> fornece mais funções para matemática, ciência e engenharia</li>
                     <li>Here is a list of some useful NumPy functions and methods names ordered in categories. See Routines for the full list.</li>
                     <ul>
                     <li>Array Creation: arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</li>
                     <li>Conversions: ndarray.astype, atleast_1d, atleast_2d, atleast_3d, mat</li>
                     <li>Manipulations: array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</li>
                     <li>Questions: all, any, nonzero, where</li>
                     <li>Ordering: argmax, argmin, argsort, max, min, ptp, searchsorted, sort</li>
                     <li>Operations: choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum</li>
                     <li>Basic Statistics: cov, mean, std, var</li>
                     <li>Basic Linear Algebra: cross, dot, outer, linalg.svd, vdot </li>
                     </ul>
                     </ul>
                     
                     </section> -->

                <section>

                    <section>
                        <h2>Broadcast</h2>
                        <ul>
                            <li>Operações no NumPy geralmente são feitas em
                                pares de arrays elemento-a-elemento </li>
                            <li class="fragment" data-fragment-index="1">Broadcast corresponde a maneira como o numpy trata arrays com <span class="green">formas diferentes</span> durante operações aritméticas</li>
                            <!-- <li>É um recurso poderoso que permite as <span class="green">ufuncs</span> (universal functions) lidar com entradas de tamanhos distintos</li> -->
                            <li class="fragment" data-fragment-index="3">O exemplo mais simples de broadcast ocorre quando um array e um escalar são combinados</span></li>
                            <li class="fragment" data-fragment-index="4">o escalar é <em class="green">esticado</em> durante a operação aritmética para ter a <span class="green">mesma forma que o array</li>
                        </ul>
                        <code-terminal dontshowcursor><in>a = np.array([1.0, 2.0, 3.0])</in>
<in>b = np.array([2.0, 2.0, 2.0])</in>
<in>a * b  # 'a' e 'b' possuem mesmo shape e podemos somar elemento-a-elemento</in>
<output>array([ 2.,  4.,  6.])</output>
<span class="fragment" data-fragment-index="3"><in>a = np.array([1.0, 2.0, 3.0])</in>
<in>b = 2.0</in>
<in>a * b</in></span>
<span class="fragment" data-fragment-index="4"><output>array([ 2.,  4.,  6.])</output></span></code-terminal>
                    </section>
                    
                    <section id="broadcast">
                        <h2>Broadcast</h2>
                        <ul>
                            <li>Além da praticidade o broadcast fornece outras vantagens:</li>
                            <ul>
                                <li class="fragment" data-fragment-index="2">É um meio de vetorizar operações com arrays tal que os <span class="green">loops ocorram em C</span>, ao invés de Python</li>
                                <li class="fragment" data-fragment-index="3"><span class="green">Sem cópias desnecessárias dos dados</span> <i class="fa fa-hand-o-right"></i> implementações eficientes de algoritmos</li>
                            </ul>
                            <aside class="notes">Multiplicar por um escalar é intuitivo. Podemos estender para um caso com mais dimensões</aside>
                            <li class="fragment" data-fragment-index="4"> Exemplo: somar uma matriz (3,3) com um vetor (3,)?
                                <ul class="fragment" data-fragment-index="5">
                                    <li>Adicionamos uma dimensão extra no vetor <i class="fa fa-hand-o-right"></i> novo shape de (1, 3)</li>
                                    <li>Replicamos o "vetor" para ter o mesmo shape que a matriz <i class="fa fa-hand-o-right"></i> (3,3)</li>
                                </ul></li>
                        </ul>
                        <svg id="broadcast-placeholder" class="displayed fragment" data-fragment-index="4" style="margin-top:20px"></svg>
                    </section>

                    <section>
                        <h2>Broadcast</h2>

                        <ul>
                            <li>Para o broadcast ser possível duas regras precisam ser atendidas:</li>
                            <ul>
                                <li><span class="green">Regra 1:</span> Se os arrays de entrada possuem ranks diferentes adicione uma dimensão no início do array menor repetidamente até que os dois tenham o mesmo rank</li>
                                <li><span class="green">Regra 2:</span> Arrays de tamanho 1 em um dada dimensão atuam
                                    como se eles tivessem o mesmo tamanho que o array
                                    de maior tamanho nessa dimensão</li>
                            </ul>
                            <li>Após a aplicação das duas regras anteriores as dimensões dos dois arrays devem bater</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Broadcast</h2>
                        <h3>Exemplos</h3>
                        <ul>
                            <li>Muito mais que operações entre um array e um simples escalar</li>
                            <li class="fragment" data-fragment-index="2">Nem sempre as dimensões coincidem após aplicar as duas regras</li>
                            <li class="fragment" data-fragment-index="3">Se for o caso você pode manualmente adicionar um eixo novo para não depender da regra 1</li>
                        </ul>
                        <code-terminal dontshowcursor><in>a = np.random.randn(2,3,4)</in>
<in>b = np.random.randn(3,4)</in>
<in>(a * b).shape  # OK: adiciona eixo 1 em b e replica para 2</in>
<output>(2, 3, 4)  # Gera um array de números aleatórios</output>
<span class="fragment" data-fragment-index="2"><in>c = np.random.randn(2, 4)</in>
<in>a + c  # Erro</in>
<span class="red">ValueError:</span> operands could not be broadcast together with shapes (2,3,4) (2,4)</span>
<span class="fragment" data-fragment-index="3"><in>(a+c[:, <span class="green">np.newaxis</span>, :]).shape  # Adicionamos um eixo extra -> novo shape: (2, 1, 4)</in>
<output>(2, 3, 4)</output></span>
<span class="fragment" data-fragment-index="4"><in>d = np.random.randn(2,3)</in>
<in>(a - d[...,<span class="green">np.newaxis</span>]).shape  # Novamente adicionamos um eixo extra -> novo shape: (2,3,1)</in>
<output>(2,3,4)</output></span></code-terminal>
                    </section>

                    <section>
                        <h2>Broadcast</h2>
                        <h3>Exercício</h3>

                        <ul>
                            <li>Dado o vetor de números complexos abaixo representando posições de pontos em um grid 2D, calcule as distâncias de cada ponto para cada outro ponto no grid.</li>
                            <pre><code>pontos = np.array([-2+1j, 3+2.5j, 2-2j, 0, 1.5+2.7j])</code></pre>
                            <li class="fragment" data-fragment-index="1">Solução:</li>
                        </ul>
                        <code-terminal class="fragment" data-fragment-index="1"><in>np.abs(pontos - pontos[:, np.newaxis])  # Só linha e sem loops!</in>
<output>
array([[ 0.        ,  5.22015325,  5.        ,  2.23606798,  3.89101529],
       [ 5.22015325,  0.        ,  4.60977223,  3.90512484,  1.5132746 ],
       [ 5.        ,  4.60977223,  0.        ,  2.82842712,  4.72652092],
       [ 2.23606798,  3.90512484,  2.82842712,  0.        ,  3.08868904],
       [ 3.89101529,  1.5132746 ,  4.72652092,  3.08868904,  0.        ]])</output></code-terminal>
                    </section>
                    
                </section>  <!-- End of broadcast -->

                <section>
                    <h2>Álgebra Linear</h2>

                    <ul>
                        <li>Numpy fornece diversos métodos para manipulação de matrizes de maneira eficiente</li>
                        <li>Por baixo dos panos bibliotecas eficientes como BLAS e LAPACK são utilizadas, tornando operações de álgebra linear eficiente</li>
                        <li>Algumas das operações mais comuns são:</li>
                        <code-terminal><in>A @ B  # Multiplica duas matrizes A e B</in>
<in>A.T  # Transposta de A</in>
<output></output>
<in>np.linalg.inv(A)  # Inversa de A</in>
<output></output>
<in>U, V = np.linalg.eig(A) # Calcula autovalores e autovetores de A</in>
<output></output>
<in>np.linalg.multi_dot([A, B, C, D])  # Calcula "A @ B @ C @ D" (mais eficiente)</in>
<output></output></code-terminal>

                    </ul>
                </section>
                
                <!-- <section>
                     <h2>Datatypes Estruturados</h2>

                     Structured datatypes

                     https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html
                     </section> -->

                <section>
                    
                    <section>
                        <h2>Plotando com Matplotlib</h2>

                        <ul>
                            <aside class="notes">Existem várias bibliotecas para plot em Python</aside>
                            <li>A biblioteca mais conhecida para plot no Python é a <a href="http://matplotlib.org/">Matplotlib</a></li>
                            <li class="fragment" data-fragment-index="1">A função mais importante é a função <code>plt.plot</code>, que recebe arrays com os valores para plotar</li>
                            <li class="fragment" data-fragment-index="2">Chame a função <code>plt.show</code> no final para mostrar o plot</li>
                            <li class="fragment" data-fragment-index="3">Com um pouco esforço a mais podemos facilmente plotar múltiplas linhas de uma só vez, adicionar um título, legenda e labels para os eixos</li>
                            <li class="fragment" data-fragment-index="4"><i class="fa fa-lightbulb-o"></i> Dica: coloque <code>%matplotlib inline</code> ou <code>%matplotlib notebook</code> na primeira célula do Jupyter notebook</li>
                        </ul>
                        <div class="container">
                            <pre class="element" style="width:58%;"><code class="python" data-noescape>import numpy as np
import matplotlib.pyplot as plt

# Computa as coordenadas 'x' e 'y' para ambas as curvas
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
<span class="fragment" data-fragment-index=4">y_cos = np.cos(x)</span>

# Plota os pontos usando matplotlib
<span class="fragment highlight-green" data-fragment-index="1">plt.plot(x, y_sin)</span>
<span class="fragment" data-fragment-index=3">plt.plot(x, y_cos)
plt.xlabel('x axis label')
plt.ylabel('y axis label')
plt.title('Sine and Cosine')
plt.legend(['Sine', 'Cosine'])</span>
<span class="fragment highlight-green" data-fragment-index="2">plt.show()</span>  # Necessário para mostrar o gráfico</code></pre>
                            
                            <div class="element" style="width:38%; height:300px; position:relative;">
                                <img class="fragment fade-out" data-fragment-index="3" alt="Plot de uma curva seno" src="imagens/numpy_part/sine_plot.png" style="background-color: white; width:100%; position:absolute;top:0;left:0;"/>
                                <img class="fragment fade-in" data-fragment-index="3" alt="Plot de uma curva seno" src="imagens/numpy_part/sine_cosine_plot.png" style="background-color: white; width:100%; position:absolute;top:0;left:0;"/>
                            </div>
                        </div>
                    </section>

                    <section>
                        <h2>Plotando com Matplotlib</h2>
                        <h3>Exercício</h3>

                        <ul>
                            <li>Repita o plot anterior no notebook, mas agora incluindo círculos nos pontos</li>
                            <li><span class="red">Dica</span>: rode o comando plt.plot? para ver a ajuda do comando</li>
                        </ul>
                    </section>
                    
                    <section>
                        <h2>Plotando com Matplotlib</h2>

                        <ul>
                            <li>Podemos plotar curvas diferentes na mesma figura usando a função <code>subplot</code></li>
                            <li>Na <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot">documentação</a> há muito mais que se pode fazer com subplots</li>
                        </ul>
                        <div class="container">
                            <pre class="element" style="width:58%;"><code class="python" data-noescape>import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Prepara um grid 2x1 para subplots e ativa o primeiro subplot
plt.subplot(2, 1, 1)

# Cria o primeiro plot
plt.plot(x, y_sin)
plt.title('Sine')

# Ativa o segundo plot do grid e cria o segundo plot
plt.subplot(2, 1, 2)
plt.plot(x, y_cos)
plt.title('Cosine')

plt.show()</code></pre>

                            <div class="element" style="background-color: white; width:38%;"><img alt="" src="imagens/numpy_part/sine_cosine_subplot.png"/></div>
                        </div>
                    </section>

                    <section>
                        <h2>Mostrando imagens com Matplotlib</h2>

                        <ul>
                            <li>Matplotlib também possui a função <code>imshow</code> que pode ser usada para mostrar uma imagem</li>
                            <li>Aqui usamos a função <code>imread</code> do scipy para ler a imagem</li>
                        </ul>

                        <div class="container">
                            <pre class="element" style="width:58%;"><code class="python" data-noescape>import numpy as np
from scipy.misc import imread, imresize
import matplotlib.pyplot as plt

img = imread('assets/cat.jpg')
img_tinted = img * [1, 0.95, 0.9]

# Mostra a imagem original
plt.subplot(1, 2, 1)
plt.imshow(img)

# Mostra a imagem modificada
plt.subplot(1, 2, 2)

# Nota: imshow resulta em resultados estranhos se os dados
# não são uint8. Para contornar esse problemas fazemos um
# cast da imagem para uint8 antes de mostrá-la
plt.imshow(np.uint8(img_tinted))
plt.show()
</code></pre>

                            <div class="element" style="background-color: white; width:38%;"><img alt="" src="imagens/numpy_part/cat_tinted_imshow.png"/></div>
                        </div>
                    </section>
                    
                </section>


                <section>
                    <section>
                        <h2>Exercícios de Fixação</h2>

                        <ol>
                            <li> Crie uma matriz A com dimensão 3 × 4 de números inteiros menores que 10</li>
                            <li> Calcule a matriz transposta de A</li>
                            <li> Calcule a soma de cada linha da matriz A usando a função sum</li>
                            <li> Calcule a soma de cada coluna da matriz A usando a função sum</li>
                            <li> Calcule a pseudo-inversa \(A^\dagger = A^T(AA^T)^{-1}\)</li>
                            <li> Defina B = AA T e calcule os autovalores e os autovetores de B usando a função eig</li>
                            <li> Calcule a inversa de B usando a função inv</li>
                        </ol>
                    </section>
                </section>

                
			</div>
		</div>

        <script src="node_modules/jquery/dist/jquery.min.js"></script>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
		 // More info https://github.com/hakimel/reveal.js#configuration
		 Reveal.initialize({
             width: 1100,
             
             
             minScale: 0.3,
             maxScale: 1.0,
             // Display controls in the bottom right corner
             controls: true,

             // Display a presentation progress bar
             progress: true,

             // Display the page number of the current slide
             slideNumber: true,
             
			 history: true,

             // Enable keyboard shortcuts for navigation
             keyboard: true,

             // Enable the slide overview mode
             overview: true,

             // Vertical centering of slides
             center: true,

             // Enables touch navigation on devices with touch input
             touch: true,

             // Turns fragments on and off globally
             fragments: true,

             // Flags if the presentation is running in an embedded mode,
             // i.e. contained within a limited portion of the screen
             embedded: false,

             // Flags if we should show a help overlay when the questionmark
             // key is pressed
             help: true,

             // Flags if speaker notes should be visible to all viewers
             showNotes: false,

             // Number of milliseconds between automatically proceeding to the
             // next slide, disabled when set to 0, this value can be overwritten
             // by using a data-autoslide attribute on your slides
             //autoSlide: 0,

             // Stop auto-sliding after user input
             //autoSlideStoppable: true,

             // Use this method for navigation when auto-sliding
             //autoSlideMethod: Reveal.navigateNext,

             // Enable slide navigation via mouse wheel
             mouseWheel: false,

             // Hides the address bar on mobile devices
             hideAddressBar: true,

             // Opens links in an iframe preview overlay
             previewLinks: false,

             // Transition style
             transition: 'convex', // none/fade/slide/convex/concave/zoom

             // Transition speed
             transitionSpeed: 'default', // default/fast/slow

             // Transition style for full page slide backgrounds
             backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

             // Number of slides away from the current that are visible
             viewDistance: 3,

             // Parallax background image
             //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

             // Parallax background size
             //parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

             // Number of pixels to move the parallax background per slide
             // - Calculated automatically unless specified
             // - Set to 0 to disable movement along an axis
             //parallaxBackgroundHorizontal: null,
             //parallaxBackgroundVertical: null

             zoomKey: 'shift',

             math: {
                 mathjax: 'node_modules/mathjax/MathJax.js',
                 config: 'TeX-AMS_HTML-full,http://localhost:8000/js/MathJax_local.js' // See http://docs.mathjax.org/en/latest/config-files.html
             },
             
			 // More info https://github.com/hakimel/reveal.js#dependencies
			 dependencies: [
				 { src: 'plugin/markdown/marked.js' },
				 { src: 'plugin/markdown/markdown.js' },
				 { src: 'plugin/notes/notes.js', async: true },
				 { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                 // Zoom in and out with Alt+click
                 { src: 'plugin/zoom-js/zoom.js', async: true },
                 // MathJax
                 { src: 'plugin/math/math.js', async: true },
                 /*                  { src: 'js/MathJax_local.js', async: true },*/
			 ]
		 });
		</script>

        <script src="js/my_d3_draws.js"></script>

        <script>
         var data2 = [{"x": 0, "y":0, "value":5.2},
                      {"x": 1, "y":0, "value":2},
                      {"x": 2, "y":0, "value":-9},
                      {"x": 3, "y":0, "value":10},
                      {"x": 0, "y":1, "value":-10},
                      {"x": 1, "y":1, "value":2},
                      {"x": 2, "y":1, "value":9},
                      {"x": 3, "y":1, "value":10}];

         var data1 = [{"x": 0, "y":0, "value":7},
                      {"x": 1, "y":0, "value":-2},
                      {"x": 2, "y":0, "value":9},
                      {"x": 3, "y":0, "value":10}];
         // Create the chart
         create_1d2d_array("#numpy-1darray", data1);
         create_1d2d_array("#numpy-2darray", data2);
         /*          create_1d2d_array("#numpy-3darray", data2);*/
        </script>

        
        <script>
         // Veja de onde você tiroi isso em
         // https://github.com/ptamarit/slides-data-viz-web-d3/blob/master/src/js/reveal-to-d3.js
         Reveal.addEventListener('slidechanged', function(event) {
             update_baterias();
             update_ipython_magic();
             update_indexa_array();
             update_indexa_array2();
             update_indexa_array3();
             update_manipulando_o_shape();
             update_C_order();
             update_fortran_order();
             update_broadcast();
             update_axis_params();
         });
         Reveal.addEventListener('fragmentshown', function(event) {
             update_baterias();
             update_ipython_magic();
             update_indexa_array();
             update_indexa_array2();
             update_indexa_array3();
             update_manipulando_o_shape();
             update_C_order();
             update_fortran_order();
             update_broadcast();
             update_axis_params();
         });
         Reveal.addEventListener('fragmenthidden', function(event) {
             update_baterias();
             update_ipython_magic();
             update_indexa_array();
             update_indexa_array2();
             update_indexa_array3();
             update_manipulando_o_shape();
             update_C_order();
             update_fortran_order()
             update_broadcast();
             update_axis_params();
         });
        </script>
     
        <!-- <script>
             function create_3d_array(id, data, data3_top) {
             "use strict";

             var max_x = d3.max(data, function (d) {return (d.x+1)*width;});
             var min_x = d3.min(data, function (d) {return (d.x)*width;});
             
             var max_y = d3.max([
             d3.max(data, function (d) {return (d.y+1)*height;}),
             d3.max(data3_top, function (d) {return (d.y+1)*height;})
             ]);
             
             var min_y = d3.min([
             d3.min(data, function (d) {return (d.y+1)*height;}),
             d3.min(data3_top, function (d) {return (d.y+1)*height;})
             ]);

             var svg_width = 300;
             var svg_height = 300;
             
             var xScale = d3.scaleLinear()
             .domain([min_x, max_x+2*width])
             .range([0, svg_width]);
             var yScale = d3.scaleLinear()
             .domain([min_y, max_y+2*height])
             .range([svg_height, 0]);
             
             var svg = d3.select(id)
             .append("svg")
             .attr("width", svg_width)
             .attr("height", svg_height)/* d3.max(data, function (d) {return (d.y+1)*height;}))*/
             .style("background-color",  "white");

             var rects = svg.selectAll("rect")
             .data(data)
             .enter()
             .append("rect");
             /* console.log(yScale(0*height));
             * console.log(yScale(1*height));
             * console.log(yScale(2*height));
             * console.log(yScale(3*height));
             * console.log(yScale(min_y));
             * console.log(yScale(max_y));*/
             
             rects.style("fill", "white")
             .style("stroke", "black")
             .attr("height", function(d) {return yScale(0)-yScale(height);})
             .attr("width", function(d) {return xScale(width);})
             .attr("x", function(d) {return xScale(d.x*width);})
             .attr("y", function(d) {return yScale((d.y+1)*height);});

             var labels = svg.selectAll("text")
             .data(data)
             .enter()
             .append("text");
             labels.attr("x", function(d) {return xScale(d.x*width+(width/2));})
             .attr("y", function(d) {return yScale(d.y*height+(height/2));})
             .attr("text-anchor", "middle")
             .attr("alignment-baseline", "central")
             .text(function(d){return d.value});

             var g = svg.append("g");
             g.selectAll("rect")
             .data(data3_top)
             .enter()
             .append("rect")
             .style("fill", "white")
             .style("stroke", "black")
             .attr("height", function(d) {return yScale(0)-yScale(height);})
             .attr("width", function(d) {return xScale(width);})
             .attr("x", function(d) {return xScale(d.x*width);})
             .attr("y", function(d) {return yScale((d.y+2)*height);});
             g.attr("transform", "matrix(1,0,-0.5,0.8660254,0,0)");
             
             function create_losangle_path(x, y, num_x, num_y, width, height) {
             "use strict"
             var x_skew = 0.5;
             var new_height = 0.7*height;
             
             for (var i=0; i < num_x; i++) {
             for(var j=0; j < num_y; j++) {
             var x_value = x*width+i*width + j*x_skew*width;
             var y_value = y*height+j*new_height;
             var s = "M{x1} {y1} L{x2} {y2} L{x3} {y3} L{x4} {y4} Z"
             .replace("{x1}", xScale(x_value))
             .replace("{y1}", yScale(y_value))
             .replace("{x2}", xScale(x_value+x_skew*width))
             .replace("{y2}", yScale(y_value+new_height))
             .replace("{x3}", xScale(x_value+(1+x_skew)*width))
             .replace("{y3}", yScale(y_value+new_height))
             .replace("{x4}", xScale(x_value+width))
             .replace("{y4}", yScale(y_value));

             var path = svg.append("path");
             path.style("stroke", "black")
             .style("fill", "white")
             .attr("d", s);
             }}
             
             /* 
             * var s2 = "M{x1} {y1} L{x2} {y2} L{x3} {y3} L{x4} {y4} Z"
             *     .replace("{x1}", xScale(x_value))
             *     .replace("{y1}", yScale(y_value))
             *     .replace("{x2}", xScale(x_value+x_skew*width))
             *     .replace("{y2}", yScale(y_value+new_height))
             *     .replace("{x3}", xScale(x_value+(1+x_skew)*width))
             *     .replace("{y3}", yScale(y_value+new_height))
             *     .replace("{x4}", xScale(x_value+width))
             *     .replace("{y4}", yScale(y_value));

             * var path2 = svg.append("path");
             * path2.style("stroke", "black")
             *      .style("fill", "white")
             *      .attr("d", s);*/
             }
             
             /*              create_losangle_path(0, 4, 3, 2, width, height);*/
             }

             var data3 = [{"x": 0, "y":0, "value":9},
             {"x": 0, "y":1, "value":1},
             {"x": 0, "y":2, "value":2},
             {"x": 0, "y":3, "value":1},
             {"x": 1, "y":0, "value":6},
             {"x": 1, "y":1, "value":3},
             {"x": 1, "y":2, "value":9},
             {"x": 1, "y":3, "value":4},
             {"x": 2, "y":0, "value":9},
             {"x": 2, "y":1, "value":0},
             {"x": 2, "y":2, "value":7},
             {"x": 2, "y":3, "value":7}]
             var data3_top = [{"x": 0, "y":3, "value":1},
             {"x": 1, "y":3, "value":4},
             {"x": 2, "y":3, "value":7}
             ]
             /* {"x": 0, "y":0, "height":height, "skewX":skewX, "value":0},
             * {"x": 1, "y":0, "height":height, "skewX":skewX, "value":1},
             * {"x": 2, "y":0, "height":height, "skewX":skewX, "value":2},

             * {"x": 0, "y":1, "height":height, "skewX":skewX, "value":0},
             * {"x": 1, "y":1, "height":height, "skewX":skewX, "value":1},
             * {"x": 2, "y":1, "height":height, "skewX":skewX, "value":2},*/
             
             create_3d_array("#numpy-3darray", data3, data3_top);
             </script> -->

        <!-- <script>
             var svg = d3.select("#numpy-3darray")
             .append("svg")
             .attr("width", 300)
             .attr("height", 200)/* d3.max(data, function (d) {return (d.y+1)*height;}))*/
             .style("background-color",  "white");
             svg.append("rect")
             .style("stroke","black")
             .style("fill","gray")
             .attr("x", 50)
             .attr("y", 50)
             .attr("width", 50)
             .attr("height", 50);
             svg.append("rect")
             .style("stroke","black")
             .style("fill","none")
             .attr("x", 50)
             .attr("y", 50)
             .attr("width", 50)
             .attr("height",50)
             .attr("transform","skewX(40)");
             </script> -->

        <!-- <script type="text/javascript">

             var width = 50;
             var height = 50;
             var data = [
             {"x": 0, "y"=0, "width"=width, "height"=height},
             {"x": 50, "y"=0, "width"=width, "height"=height},
             {"x": 100, "y"=0, "width"=width, "height"=height},
             {"x": 150, "y"=0, "width"=width, "height"=height}]
             
             var svg = d3.select("#numpy-1darray")
             .append("svg")
             .attr("width", 500)
             .attr("height", 300)
             .style("background-color",  "white");

             rects = svg.select("rect")
             .data(data)
             .enter()
             .append("rect");

             rects.attr("width", function (d){ return d.width})
             .attr("height", function (d){ return d.height});
             /* .style("stroke", "gray")
             * .style("fill", "white")
             * .attr("width", 100)
             * .attr("height", 100)
             * .attr("x", 50)
             * .attr("y", 50)
             * .on("mouseover", function(){d3.select(this).style("fill", "aliceblue");})
             * .on("mouseout", function(){d3.select(this).style("fill", "white");});*/
             </script> -->
	</body>
</html>
